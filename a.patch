oFrom 491619f9ea2e972787a0f00aed9d198118d85599 Mon Sep 17 00:00:00 2001
From: Moizpgedge <moiz@pgedge.com>
Date: Fri, 17 Jan 2025 17:53:21 +0500
Subject: [PATCH] backrest in init function cipher issue

---
 cli/scripts/cluster.py | 186 +++++++++++++++++++++++++++++++++++++----
 1 file changed, 171 insertions(+), 15 deletions(-)

diff --git a/cli/scripts/cluster.py b/cli/scripts/cluster.py
index b9574102..13c5aa42 100755
--- a/cli/scripts/cluster.py
+++ b/cli/scripts/cluster.py
@@ -977,14 +977,25 @@ def json_create(
             util.exit_message(
                 "Invalid BackRest archive mode. Allowed values are 'on' or 'off'."
             )
-
+         # Optionally, ask for repo1_type or default to posix
+        repo1_type = (
+            input("   pgBackRest repository type (posix/s3) (default: posix): ")
+            .strip()
+            .lower()
+            or "posix"
+        )
+        if repo1_type not in ["posix", "s3"]:
+            util.exit_message(
+                "Invalid BackRest repository type. Allowed values are 'posix' or 's3'."
+            )
         backrest_json = {
             "stanza": "demo_stanza",
-            "repo1-path": backrest_storage_path,
-            "repo1-retention-full": "7",
-            "log-level-console": "info",
-            "repo1-cipher-type": "aes-256-cbc",
+            "repo1_path": backrest_storage_path,
+            "repo1_retention_full": "7",
+            "log_level_console": "info",
+            "repo1_cipher-type": "aes-256-cbc",
             "archive_mode": backrest_archive_mode,
+            "repo1_type": repo1_type,
         }
     else:
         backrest_json = None
@@ -1310,24 +1321,33 @@ def update_json(cluster_name, db_json):
         util.exit_message("Unable to update JSON file", 1)
 
 
+
 def init(cluster_name, install=True):
     """
     Initialize a cluster via Cluster Configuration JSON file.
 
-    Install pgEdge on each node, create the initial database, install Spock,
-    and create all Spock nodes and subscriptions. Additional databases will
-    be created with all Spock nodes and subscriptions if defined in the JSON
-    file. This command requires a JSON file with the same name as the cluster
-    to be in the cluster/<cluster_name>.
+    This function performs the following steps:
+    1. Loads the cluster configuration.
+    2. Checks SSH connectivity for all nodes.
+    3. Installs pgEdge on all nodes.
+    4. Configures Spock for replication.
+    5. Integrates pgBackRest on nodes where it is enabled.
+    6. Creates an initial full backup using pgBackRest.
+    7. Performs HA-specific configurations if enabled.
+    8. Finalizes and saves the cluster configuration.
 
     Args:
         cluster_name (str): The name of the cluster.
-        install (bool): True by default,
+        install (bool): Whether to install pgEdge on nodes. Defaults to True.
     """
-    util.message(f"## Loading cluster '{cluster_name}' json definition file")
+    # Load cluster configuration
+    util.message(f"## Loading cluster '{cluster_name}' JSON definition file", "info")
     db, db_settings, nodes = load_json(cluster_name)
     parsed_json = get_cluster_json(cluster_name)
 
+    if parsed_json is None:
+        util.exit_message("Unable to load cluster JSON", 1)
+
     # Retrieve the 'is_ha_cluster' flag from the cluster JSON
     is_ha_cluster = parsed_json.get("is_ha_cluster", False)
 
@@ -1341,11 +1361,13 @@ def init(cluster_name, install=True):
             all_nodes.extend(node["sub_nodes"])
 
     # Check SSH connectivity for all nodes
+    util.message("## Checking SSH connectivity for all nodes", "info")
     for nd in all_nodes:
-        message = f"Checking ssh on {nd['public_ip']}"
+        message = f"Checking SSH connectivity on {nd['public_ip']}"
         run_cmd(cmd="hostname", node=nd, message=message, verbose=verbose)
 
     # Install pgEdge on all nodes
+    util.message("## Installing pgEdge on all nodes", "info")
     ssh_install_pgedge(
         cluster_name,
         db[0]["db_name"],
@@ -1357,7 +1379,8 @@ def init(cluster_name, install=True):
         verbose,
     )
 
-    # Cross-wire Spock on all nodes
+    # Configure Spock replication on all nodes
+    util.message("## Configuring Spock replication on all nodes", "info")
     ssh_cross_wire_pgedge(
         cluster_name,
         db[0]["db_name"],
@@ -1370,8 +1393,9 @@ def init(cluster_name, install=True):
 
     # Handle additional databases if any
     if len(db) > 1:
+        util.message("## Configuring additional databases", "info")
         for database in db[1:]:
-            create_spock_db(all_nodes, database, db_settings, False)
+            create_spock_db(all_nodes, database, db_settings, initial=False)
             ssh_cross_wire_pgedge(
                 cluster_name,
                 database["db_name"],
@@ -1382,6 +1406,137 @@ def init(cluster_name, install=True):
                 verbose,
             )
 
+    # ### BackRest Configuration Integration ###
+    # Configure BackRest on all nodes if enabled
+    util.message("## Integrating pgBackRest into the cluster", "info")
+    for node in all_nodes:
+        backrest = node.get("backrest")
+        if backrest:
+            util.message(f"### Configuring BackRest for node '{node['name']}'", "info")
+
+            # Extract BackRest settings with defaults
+            stanza = backrest.get("stanza", f"pg{db_settings['pg_version']}")
+            repo1_retention_full = backrest.get("repo1_retention_full", "7")
+            log_level_console = backrest.get("log_level_console", "info")
+            repo1_cipher_type = backrest.get("repo1_cipher_type", "aes-256-cbc")
+            repo1_path = backrest.get("repo1_path", f"/var/lib/pgbackrest/{node['name']}")
+            repo1_type = backrest.get("repo1_type", "posix")  # Ensure this is correctly set
+            archive_mode = backrest.get("archive_mode", "on")
+
+            pg_version = db_settings["pg_version"]
+            pg1_path = f"{node['path']}/pgedge/data/pg{pg_version}"
+            port = node["port"]
+
+            # 1. Install BackRest
+            cmd_install_backrest = (
+                f"cd {node['path']}/pgedge && ./pgedge install backrest"
+            )
+            run_cmd(
+                cmd_install_backrest,
+                node=node,
+                message="Installing pgBackRest",
+                verbose=verbose,
+            )
+
+            # 2. Set Backup Configuration using set_postgresqlconf
+            # Pass all 4 required parameters with flags
+            cmd_set_postgresqlconf = (
+                f"cd {node['path']}/pgedge && "
+                f"./pgedge backrest set_postgresqlconf --stanza {stanza} "
+                f"--pg1-path {pg1_path} --repo1-path {repo1_path} --repo1-type {repo1_type}"
+            )
+            run_cmd(
+                cmd_set_postgresqlconf,
+                node=node,
+                message="Modifying postgresql.conf for BackRest",
+                verbose=verbose,
+            )
+
+            # 3. Set pg_hba.conf for BackRest
+            cmd_set_hbaconf = (
+                f"cd {node['path']}/pgedge && ./pgedge backrest set_hbaconf"
+            )
+            run_cmd(
+                cmd_set_hbaconf,
+                node=node,
+                message="Modifying pg_hba.conf for BackRest",
+                verbose=verbose,
+            )
+
+            # 4. Reload PostgreSQL Configuration
+            sql_reload_conf = "select pg_reload_conf()"
+            cmd_reload_conf = (
+                f"cd {node['path']}/pgedge && "
+                f"./pgedge psql '{sql_reload_conf}' {db[0]['db_name']}"
+            )
+            run_cmd(
+                cmd_reload_conf,
+                node=node,
+                message="Reloading PostgreSQL configuration",
+                verbose=verbose,
+            )
+
+            # 5. Handle repo1_type S3 if applicable
+            if repo1_type.lower() == "s3":
+                required_env_vars = [
+                    "PGBACKREST_REPO1_S3_KEY",
+                    "PGBACKREST_REPO1_S3_BUCKET",
+                    "PGBACKREST_REPO1_S3_KEY_SECRET",
+                    "PGBACKREST_REPO1_CIPHER_PASS",
+                ]
+                missing_env_vars = [
+                    var for var in required_env_vars if var not in os.environ
+                ]
+                if missing_env_vars:
+                    util.exit_message(
+                        f"Environment variables {', '.join(missing_env_vars)} must be set for S3 BackRest configuration.",
+                        1,
+                    )
+
+                # Export S3 environment variables on the node
+                s3_exports = " && ".join(
+                    [f"export {var}={os.environ[var]}" for var in required_env_vars]
+                )
+                cmd_export_s3 = f"cd {node['path']}/pgedge && {s3_exports}"
+                run_cmd(
+                    cmd_export_s3,
+                    node=node,
+                    message="Setting S3 environment variables for BackRest",
+                    verbose=verbose,
+                )
+
+            # 6. Create BackRest Stanza
+            # Pass the stanza and pg1_path using flags
+            cmd_create_stanza = (
+                f"cd {node['path']}/pgedge && "
+                f"./pgedge backrest command stanza-create --stanza '{stanza}' --pg1-path '{pg1_path}'"
+            )
+            run_cmd(
+                cmd_create_stanza,
+                node=node,
+                message=f"Creating BackRest stanza '{stanza}'",
+                verbose=verbose,
+            )
+
+            # 7. Create a Full BackRest Backup
+            # Ensure that the 'repo1_path' used here matches the one set in 'set_postgresqlconf'
+            backrest_backup_args = (
+                f"--repo1-path {repo1_path} --stanza {stanza} "
+                f"--pg1-path {pg1_path} --repo1-type {repo1_type} "
+                f"--log-level-console {log_level_console} --pg1-port {port} "
+                f"--db-socket-path /tmp --repo1-cipher-type {repo1_cipher_type} "
+                f"--repo1-retention-full {repo1_retention_full} --type=full"
+            )
+            cmd_create_backup = (
+                f"cd {node['path']}/pgedge && "
+                f"./pgedge backrest command backup '{backrest_backup_args}'"
+            )
+            run_cmd(
+                cmd_create_backup,
+                node=node,
+                message="Creating full BackRest backup",
+                verbose=verbose,
+            )
     # Proceed with HA-specific configuration only if 'is_ha_cluster' is True
     if is_ha_cluster:
         pg_ver = db_settings["pg_version"]
@@ -1406,6 +1561,7 @@ def init(cluster_name, install=True):
                 ha_patroni.configure_patroni(node, sub_nodes, db[0], db_settings)
 
 
+
 def add_node(
     cluster_name,
     source_node,
-- 
2.43.5


