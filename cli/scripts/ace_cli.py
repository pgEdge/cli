from datetime import datetime
import json
import traceback
import ace_config as config
import ace_core
import ace_daemon
import ace_db
from ace_data_models import (
    RepsetDiffTask,
    SchemaDiffTask,
    SpockDiffTask,
    TableDiffTask,
    TableRepairTask,
)
import ace
import util
from ace_exceptions import AceException


def table_diff_cli(
    cluster_name,
    table_name,
    dbname=None,
    block_rows=config.BLOCK_ROWS_DEFAULT,
    max_cpu_ratio=config.MAX_CPU_RATIO_DEFAULT,
    output="json",
    nodes="all",
    batch_size=config.BATCH_SIZE_DEFAULT,
    table_filter=None,
    quiet=False,
):
    """
    Compare a table across a cluster and produce a report showing 
    any differences.

    Args:
        cluster_name (str): Name of the cluster where the operation should be performed.
        table_name (str): Schema-qualified name of the table that you are 
            comparing across cluster nodes.
        dbname (str, optional): Name of the database. Defaults to the name of 
            the first database in the cluster configuration.
        block_rows (int, optional): Number of rows to process per block. 
            Defaults to config.BLOCK_ROWS_DEFAULT. 
        max_cpu_ratio (float, optional): Maximum CPU utilisation. The accepted 
            range is 0.0-1.0. Defaults to config.MAX_CPU_RATIO_DEFAULT.
        output (str, optional): Output format. Acceptable values are "json" or 
            "csv". Defaults to "json".
        nodes (str, optional): Comma-delimited subset of nodes on which the 
            command will be executed. Defaults to "all".
        batch_size (int, optional): Size of each batch. Defaults to 
            config.BATCH_SIZE_DEFAULT.
        table_filter (str, optional): A SQL WHERE clause that allows you to 
            filter rows for comparison.
        quiet (bool, optional): Whether to suppress output in stdout. Defaults 
            to False.

    Raises:
        AceException: If there's an error specific to the ACE operation.
        Exception: For any unexpected errors during the table diff operation.

    Returns:
        None. The function performs the table diff operation and handles any 
        exceptions. All output messages are printed to stdout since it's a CLI 
        function.
    """
    task_id = ace_db.generate_task_id()

    try:
        td_task = TableDiffTask(
            cluster_name=cluster_name,
            _table_name=table_name,
            _dbname=dbname,
            block_rows=block_rows,
            max_cpu_ratio=max_cpu_ratio,
            output=output,
            _nodes=nodes,
            batch_size=batch_size,
            quiet_mode=quiet,
            table_filter=table_filter,
            invoke_method="cli",
        )
        td_task.scheduler.task_id = task_id
        td_task.scheduler.task_type = "table-diff"
        td_task.scheduler.task_status = "RUNNING"
        td_task.scheduler.started_at = datetime.now()

        ace.validate_table_diff_inputs(td_task)
        ace_db.create_ace_task(task=td_task)
        ace_core.table_diff(td_task)
        td_task.connection_pool.close_all()
    except AceException as e:
        util.exit_message(str(e))
    except Exception as e:
        traceback.print_exc()
        util.exit_message(f"Unexpected error while running table diff: {e}")


def table_repair_cli(
    cluster_name,
    table_name,
    diff_file,
    source_of_truth=None,
    dbname=None,
    dry_run=False,
    quiet=False,
    generate_report=False,
    insert_only=False,
    upsert_only=False,
    fix_nulls=False,
    fire_triggers=False,
    bidirectional=False,
):
    """
    Repair a table across a cluster by fixing data inconsistencies identified 
    in a table-diff operation.

    Args:
        cluster_name (str): Name of the cluster where the operation should be performed.
        diff_file (str): Path to the diff file generated by a previous table diff.
        source_of_truth (str): Node name to be used as the source of truth for 
            the repair.
        table_name (str): Schema-qualified name of the table that you are 
            comparing across cluster nodes.
        dbname (str, optional): Name of the database. Defaults to the name of 
            the first database in the cluster configuration.
        dry_run (bool, optional): If True, simulates the repair without making 
            changes. Defaults to False.
        generate_report (bool, optional): If True, generates a detailed report 
            of the repair. Defaults to False.
        upsert_only (bool, optional): If True, only performs upsert operations, 
            skipping deletions. Defaults to False.
        insert_only (bool, optional): If True, only performs insert operations, 
            skipping updates and deletions.
        fix_nulls (bool, optional): If True, fixes null values in the table 
            columns by looking at the corresponding column in the other nodes. 
            Does not need the source of truth to be specified. Must be used 
            only in special cases. This is not a recommended option for 
            repairing divergence. Defaults to False.
        fire_triggers (bool, optional): If True, instructs triggers to fire 
            when a repair is performed; note that ENABLE ALWAYS triggers will 
            fire regardless of the value.
        bidirectional (bool, optional): If True, performs a bidirectional 
            repair, applies differences found between nodes to create a 
            distinct union of the content. In a distinct union, each row that 
            is missing is recreated on the node from which it is missing, 
            eventually leading to a data set (on all nodes) in which all rows 
            are represented exactly once.
        quiet (bool, optional): Whether to suppress output in stdout. Defaults 
            to False.

    Raises:
        AceException: If there's an error specific to the ACE operation.
        Exception: For any unexpected errors during the table repair operation.

    Returns:
        None. The function performs the table repair operation and handles any 
        exceptions. All output messages are printed to stdout since it's a CLI 
        function.
    """
    task_id = ace_db.generate_task_id()

    try:
        tr_task = TableRepairTask(
            cluster_name=cluster_name,
            diff_file_path=diff_file,
            source_of_truth=source_of_truth,
            _table_name=table_name,
            _dbname=dbname,
            dry_run=dry_run,
            quiet_mode=quiet,
            generate_report=generate_report,
            insert_only=insert_only,
            upsert_only=upsert_only,
            fix_nulls=fix_nulls,
            fire_triggers=fire_triggers,
            bidirectional=bidirectional,
            invoke_method="cli",
        )
        tr_task.scheduler.task_id = task_id
        tr_task.scheduler.task_type = "table-repair"
        tr_task.scheduler.task_status = "RUNNING"
        tr_task.scheduler.started_at = datetime.now()

        ace.validate_table_repair_inputs(tr_task)
        ace_db.create_ace_task(task=tr_task)

        if fix_nulls:
            ace_core.table_repair_fix_nulls(tr_task)
        elif bidirectional:
            ace_core.table_repair_bidirectional(tr_task)
        else:
            ace_core.table_repair(tr_task)

        tr_task.connection_pool.close_all()
    except AceException as e:
        util.exit_message(str(e))
    except Exception as e:
        traceback.print_exc()
        util.exit_message(f"Unexpected error while running table repair: {e}")

def table_rerun_cli(
    cluster_name,
    diff_file,
    table_name,
    dbname=None,
    quiet=False,
    behavior="multiprocessing",
    table_filter=None,
):
    """
    Reruns a table diff operation based on a previous diff file.

    Args:
        cluster_name (str): Name of the cluster where the operation should be performed.
        diff_file (str): Path to the diff file from a previous table diff 
            operation.
        table_name (str): Schema-qualified name of the table that you are 
            comparing across cluster nodes.
        dbname (str, optional): Name of the database. Defaults to the name of 
            the first database in the cluster configuration.
        behavior (str, optional): The rerun behavior, either "multiprocessing" 
            or "hostdb". "multiprocessing" uses parallel processing for faster 
            execution. "hostdb" uses the host database to create temporary 
            tables for faster comparisons. Defaults to "multiprocessing".
        table_filter (str, optional): A SQL WHERE clause that allows you to 
            filter rows for comparison.
        quiet (bool, optional): Whether to suppress output in stdout. Defaults 
            to False.

    Raises:
        AceException: If there's an error specific to the ACE operation.
        Exception: For any unexpected errors during the table rerun operation.

    Returns:
        None. The function performs the table rerun operation and handles any 
        exceptions. All output messages are printed to stdout since it's a CLI 
        function.
    """
    task_id = ace_db.generate_task_id()

    try:
        td_task = TableDiffTask(
            cluster_name=cluster_name,
            _table_name=table_name,
            _dbname=dbname,
            block_rows=config.BLOCK_ROWS_DEFAULT,
            max_cpu_ratio=config.MAX_CPU_RATIO_DEFAULT,
            output="json",
            _nodes="all",
            batch_size=config.BATCH_SIZE_DEFAULT,
            table_filter=table_filter,
            quiet_mode=quiet,
            diff_file_path=diff_file,
            invoke_method="cli",
        )
        td_task.scheduler.task_id = task_id
        td_task.scheduler.task_type = "table-rerun"
        td_task.scheduler.task_status = "RUNNING"
        td_task.scheduler.started_at = datetime.now()

        ace.validate_table_diff_inputs(td_task)
        ace_db.create_ace_task(task=td_task)
    except AceException as e:
        util.exit_message(str(e))
    except Exception as e:
        traceback.print_exc()
        util.exit_message(f"Unexpected error while running table rerun: {e}")

    try:
        if behavior == "multiprocessing":
            ace_core.table_rerun_async(td_task)
        elif behavior == "hostdb":
            ace_core.table_rerun_temptable(td_task)
        else:
            util.exit_message(f"Invalid behavior: {behavior}")

        td_task.connection_pool.close_all()
    except AceException as e:
        util.exit_message(str(e))
    except Exception as e:
        traceback.print_exc()
        util.exit_message(f"Unexpected error while running table rerun: {e}")


def repset_diff_cli(
    cluster_name,
    repset_name,
    dbname=None,
    block_rows=config.BLOCK_ROWS_DEFAULT,
    max_cpu_ratio=config.MAX_CPU_RATIO_DEFAULT,
    output="json",
    nodes="all",
    batch_size=config.BATCH_SIZE_DEFAULT,
    quiet=False,
    skip_tables=None,
    skip_file=None,
):
    """
    Compare a repset across a cluster and produce a report showing 
    any differences.

    Args:
        cluster_name (str): Name of the cluster where the operation should be performed.
        repset_name (str): Name of the repset to compare across cluster nodes.
        dbname (str, optional): Name of the database. Defaults to the name of 
            the first database in the cluster configuration.
        block_rows (int, optional): Number of rows to process per block. 
            Defaults to config.BLOCK_ROWS_DEFAULT. 
        max_cpu_ratio (float, optional): Maximum CPU utilisation. The accepted 
            range is 0.0-1.0. Defaults to config.MAX_CPU_RATIO_DEFAULT.
        output (str, optional): Output format. Acceptable values are "json" or 
            "csv". Defaults to "json".
        nodes (str, optional): Comma-delimited subset of nodes on which the 
            command will be executed. Defaults to "all".
        batch_size (int, optional): Size of each batch. Defaults to 
            config.BATCH_SIZE_DEFAULT.
        quiet (bool, optional): Whether to suppress output in stdout. Defaults 
            to False.
        skip_tables (list, optional): Comma-deliminated list of tables to skip.
        skip_file (str, optional): Path to a file containing a list of tables to skip.

    Raises:
        AceException: If there's an error specific to the ACE operation.
        Exception: For any unexpected errors during the repset diff operation.

    Returns:
        None. The function performs the repset diff operation and handles any
        exceptions. All output messages are printed to stdout since it's a CLI
        function.
    """
    task_id = ace_db.generate_task_id()

    try:
        rd_task = RepsetDiffTask(
            cluster_name=cluster_name,
            _dbname=dbname,
            repset_name=repset_name,
            block_rows=block_rows,
            max_cpu_ratio=max_cpu_ratio,
            output=output,
            _nodes=nodes,
            batch_size=batch_size,
            quiet_mode=quiet,
            invoke_method="cli",
            skip_tables=skip_tables,
            skip_file=skip_file,
        )
        rd_task.scheduler.task_id = task_id
        rd_task.scheduler.task_type = "repset-diff"
        rd_task.scheduler.task_status = "RUNNING"
        rd_task.scheduler.started_at = datetime.now()

        ace.validate_repset_diff_inputs(rd_task)
        ace_db.create_ace_task(task=rd_task)
        ace_core.multi_table_diff(rd_task)

        # TODO: Figure out a way to handle repset-level connection pooling
        # This close_all() is redundant currently
        rd_task.connection_pool.close_all()
    except AceException as e:
        util.exit_message(str(e))
    except Exception as e:
        traceback.print_exc()
        util.exit_message(f"Unexpected error while running repset diff: {e}")


def spock_diff_cli(
    cluster_name,
    dbname=None,
    nodes="all",
    quiet=False,
):
    """
    Compare the spock metadata across a cluster and produce a report showing 
    any differences.

    Args:
        cluster_name (str): Name of the cluster where the operation should be 
            performed.
        dbname (str, optional): Name of the database. Defaults to the name of 
            the first database in the cluster configuration.
        nodes (str, optional): Comma-delimited subset of nodes on which the 
            command will be executed. Defaults to "all".
        quiet (bool, optional): Whether to suppress output in stdout. Defaults 
            to False.

    Raises:
        AceException: If there's an error specific to the ACE operation.
        Exception: For any unexpected errors during the spock diff operation.

    Returns:
        None. The function performs the spock diff operation and handles any 
        exceptions. All output messages are printed to stdout since it's a CLI 
        function.
    """
    task_id = ace_db.generate_task_id()

    try:
        sd_task = SpockDiffTask(
            cluster_name=cluster_name,
            _dbname=dbname,
            _nodes=nodes,
            quiet_mode=quiet,
            invoke_method="cli",
        )
        sd_task.scheduler.task_id = task_id
        sd_task.scheduler.task_type = "spock-diff"
        sd_task.scheduler.task_status = "RUNNING"
        sd_task.scheduler.started_at = datetime.now()

        ace.validate_spock_diff_inputs(sd_task)
        ace_db.create_ace_task(task=sd_task)
        ace_core.spock_diff(sd_task)
        sd_task.connection_pool.close_all()
    except AceException as e:
        util.exit_message(str(e))
    except Exception as e:
        traceback.print_exc()
        util.exit_message(f"Unexpected error while running spock diff: {e}")


def schema_diff_cli(
    cluster_name,
    schema_name,
    nodes="all",
    dbname=None,
    ddl_only=True,
    skip_tables=None,
    skip_file=None,
    quiet=False,
):
    """
    Compare a schema across a cluster and produce a report showing 
    any differences.

    Args:
        cluster_name (str): Name of the cluster where the operation should 
            be performed.
        schema_name (str): Name of the schema that you are comparing across 
            cluster nodes.
        nodes (str, optional): Comma-delimited subset of nodes on which the 
            command will be executed. Defaults to "all".
        dbname (str, optional): Name of the database. Defaults to the name of 
            the first database in the cluster configuration.
        ddl_only (bool, optional): If True, only compares DDL differences 
            across nodes.
        skip_tables (list, optional): Comma-delimited list of tables to skip.
        skip_file (str, optional): Path to a file containing a list of tables 
            to skip.
        quiet (bool, optional): Whether to suppress output in stdout. Defaults 
            to False.

    Raises:
        AceException: If there's an error specific to the ACE operation.
        Exception: For any unexpected errors during the schema diff operation.

    Returns:
        None. The function performs the schema diff operation and handles any 
        exceptions. All output messages are printed to stdout since it's a CLI 
        function.
    """
    task_id = ace_db.generate_task_id()

    try:
        sc_task = SchemaDiffTask(
            cluster_name=cluster_name,
            schema_name=schema_name,
            _dbname=dbname,
            _nodes=nodes,
            ddl_only=ddl_only,
            skip_tables=skip_tables,
            skip_file=skip_file,
            quiet_mode=quiet,
            invoke_method="cli",
        )
        sc_task.scheduler.task_id = task_id
        sc_task.scheduler.task_type = "schema-diff"
        sc_task.scheduler.task_status = "RUNNING"
        sc_task.scheduler.started_at = datetime.now()

        ace.schema_diff_checks(sc_task)
        ace_db.create_ace_task(task=sc_task)
        if ddl_only:
            ace_core.schema_diff_objects(sc_task)
        else:
            ace_core.multi_table_diff(sc_task)
        sc_task.connection_pool.close_all()
    except AceException as e:
        util.exit_message(str(e))
    except Exception as e:
        traceback.print_exc()
        util.exit_message(f"Unexpected error while running schema diff: {e}")


def update_spock_exception_cli(cluster_name, node_name, entry, dbname=None) -> None:
    """
    Updates the Spock exception status for a specified cluster and node.

    Args:
        cluster_name (str): Name of the cluster where the operation should 
            be performed.
        node_name (str): The name of the node within the cluster where the 
            update should be performed.
        entry (str): The exception entry in JSON format.
        dbname (str, optional): Name of the database. Defaults to the name of 
            the first database in the cluster configuration.

    Raises:
        AceException: If an error specific to the ACE system occurs.
        json.JSONDecodeError: If the provided exception entry is not valid 
            JSON.
        Exception: For any other unexpected errors.

    Returns:
        None
    """

    try:
        conn = ace.update_spock_exception_checks(cluster_name, node_name, entry, dbname)
        ace_core.update_spock_exception(entry, conn)
    except AceException as e:
        util.exit_message(str(e))
    except json.JSONDecodeError:
        util.exit_message("Exception entry is not a valid JSON")
    except Exception as e:
        traceback.print_exc()
        util.exit_message(f"Unexpected error while running exception status: {e}")

    util.message("Spock exception status updated successfully", p_state="success")

def auto_repair_cli() -> None:
    """
    Invoke the automatic repair process.
    """
    ace_core.auto_repair()

def start_cli() -> None:
    """
    Start the ACE background scheduler and API
    """
    ace_daemon.start_ace()